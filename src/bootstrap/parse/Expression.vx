import @/util/SetFromArray.vx;

import p from '@/parse/parse.vx';

import @/parse/CommaSequence.vx;
import @/parse/Identifier.vx;
import @/parse/Literal/Literal.vx;
import @/parse/Whitespace.vx;

func Expression(lines, [lineNo, colNo]) {
  OW := p.Optional(Whitespace);

  assignmentOperators := #[
    ':=', '=', '**=', '+=', '++=', '-=', '*=', '/=', '%=', '<<=', '>>=', '&=',
    '|=', '^=', '&&=', '||=', '~='
  ];

  binaryOperators := [
    ['right', ['**']],
    ['left', ['*', '/', '%']],
    ['left', ['++', '+', '-']],
    ['left', ['<<', '>>']],
    ['left', ['<', '>', '<=', '>=']],
    ['left', ['==', '!=']],
    ['left', ['~']],
    ['left', ['&']],
    ['left', ['^']],
    ['left', ['|']],
    ['left', ['&&']],
    ['left', ['||']],
    ['left', ['in']],
    ['right', assignmentOperators:Values()],
  ];

  operators := binaryOperators:map(func([_, ops]) => ops):reduce(++);
  Operator := p.Select(operators:map(p.Exact));

  ParenExp := p.Transform(
    p.SequenceOne([
      [p.Exact('(')],
      Expression,
      [p.Exact(')')],
    ]),
    func([_, exp, _]) => exp,
  );

  suffixParsers := {
    Prop: p.Transform(
      p.SequenceOne([
        [p.Exact('.')],
        Identifier,
      ]),
      func([_, name]) => ['.', name],
    ),
    Method: p.Transform(
      p.SequenceOne([
        [p.Exact(':')],
        Identifier,
      ]),
      func([_, name]) => ['methodLookup', name],
    ),
    Sub: p.Transform(
      p.SequenceOne([
        [p.Exact('[')],
        Expression,
        [p.Exact(']')],
      ]),
      func(exp) => ['subscript', exp],
    ),
    Call: p.Transform(
      p.SequenceOne([
        [p.Exact('(')],
        CommaSequence(Expression),
        [p.Exact(')')],
      ]),
      func(params) => ['functionCall', params],
    ),
  };

  AtomicExp := p.Select([
    Identifier,
    Literal,
    ParenExp,
  ]);

  Access := p.Transform(
    p.Sequence([
      AtomicExp,
      p.Many(p.Select(suffixParsers:Values())),
    ]),
    func([exp, suffixes]) {
      for ([op, rhs] of suffixes) {
        exp = [op, [exp, rhs]];
      }

      return exp;
    },
  );

  func joinUnaries([head, tail]) {
    opLists := tail:map(func([ops, _]) => ops);
    exps := [head] ++ tail:map(func([_, exp]) => exp);

    for (i := 0u64; i < opLists:Length(); i++) {
      j := 0u64;

      for (j < opLists[i]:Length() - 1u64) {
        op := opLists[i][j];

        if (op in #['++', '--']) {
          exps[i] = ['unary ' ++ op, exps[i]];
        } else {
          break;
        }

        j++;
      }

      J := opLists[i]:Length() - 1u64;

      for (j < J) {
        op := opLists[i][J];

        if (op in #['!', '~', '+', '-']) {
          exps[i + 1u64] = ['unary ' ++ op, exps[i + 1u64]];
        } else {
          break;
        }

        J--;
      }

      if (j != J) {
        return ['invalid', (
          'could not join operators ' ++
          opLists[i]:String() ++
          ' with neighboring expressions'
        )];
      }

      opLists[i] = opLists[i][j];
    }

    return ['joined', {exps, ops: opLists}];
  };

  func joinBinaries({exps, ops}) {
    for ([direction, dirOps] of binaryOperators) {
      nextExps := [];
      nextOps := [];

      assert exps:Length() == ops:Length() + 1u64;

      if (exps:Length() == 1u64) {
        return ['joined', exps:Front()];
      }

      dirOpsSet := SetFromArray(dirOps);

      if (direction == 'left') {
        currExp := exps:Front();

        for (i := 0u64; i < ops:Length(); i++) {
          op := ops[i];

          if (op in dirOpsSet) {
            currExp = [op, [currExp, exps[i + 1u64]]];
          } else {
            nextExps ++= [currExp];
            currExp = exps[i + 1u64];
            nextOps ++= [op];
          }
        }

        nextExps ++= [currExp];
      } else if (direction == 'right') {
        currExp := exps:Back();

        i := ops:Length() - 1u64;

        for {
          op := ops[i];

          if (op in dirOpsSet) {
            currExp = [op, [exps[i], currExp]];
          } else {
            nextExps = [currExp] ++ nextExps;
            currExp = exps[i];
            nextOps = [op] ++ nextOps;
          }

          if (i == 0u64) {
            break;
          } else {
            i--;
          }
        }

        nextExps = [currExp] ++ nextExps;
      } else {
        assert false;
      }

      exps = nextExps;
      ops = nextOps;
    }

    assert false;
    return null; // TODO: Should be unnecessary
  };

  return p.Transform(
    p.Sequence([
      Access,
      p.Many(p.Sequence([
        p.Repeat(
          p.SequenceOne([[OW], Operator]),
          [1u64, null],
        ),
        [OW],
        Access,
      ])),
    ]),
    func([head, tail]) {
      [type, data] := joinUnaries([head, tail]);

      if (type == 'invalid') {
        return [type, data];
      }

      [type, data] = joinBinaries(data);
      assert type == 'joined';

      return data;
    },
  )(lines, [lineNo, colNo]);
};

log.info p.Complete(Expression)(['foo(1 + 1)']);
log.info p.Complete(Expression)(['foo(1, 1)']);

return 'done';
