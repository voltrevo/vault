import @/parser/expressionTypes.vx;
import @/parser/operatorTypes.vx;
import @/util/kinds.vx;

return func KindSet([type, data, _]) {
  if (type in #['import', 'identifier']) {
    return kinds.all;
  }

  if (type in #['default', 'note']) {
    // Is it ok to call KindSet with 'note'? Maybe caller should always be
    // bubbling note instead.
    return #[];
  }

  if (type == 'op') {
    return #['func'];
  }

  if (type == 'literal') {
    return #[data:Kind()];
  }

  if (type in expressionTypes.operator) {
    return switch {
      (type in operatorTypes.mutation) => #[];
      (type in #['functionCall', 'subscript']) => kinds.all;

      (type in #[
        '==',
        '!=',
        '<=',
        '>=',
        '<',
        '>',
        '&&',
        '||',
        'in',
        'unary !',
      ]) => (
        #['bool']
      );

      (type in #['%', '<<', '>>', 'unary ~']) => kinds.number;
      (type == '++') => #['array', 'object'];

      (type in #['unary +', 'unary -', '**', '*', '/', '+', '-']) => (
        kinds.arithmetic
      );

      (type in #['~', '&', '^', '|']) => #['set'] | kinds.number;
    };
  }

  if (type in expressionTypes.container) {
    return #[type];
  }

  if (type in expressionTypes.nameAccess) {
    return kinds.all;
  }

  if (type == 'switch') {
    {test: _, cases} := data;

    res := #[];

    for ([_, rhs] of cases) {
      res |= KindSet(rhs);
    }

    return res;
  }

  if (type == 'func') {
    return #['func'];
  }

  assert false;
  return null;
};
