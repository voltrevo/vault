import @/util/aan.vx;

import ./expressionTypes.vx;
import ./operatorTypes.vx;

func Expression(expression) {
  notes := [];

  [type, data, pos] := expression;

  if (type in expressionTypes.operator) {
    for ([subType, _, subPos] of data) {
      if (subType in operatorTypes.mutation) {
        notes ++= [{
          level: 'error',
          message: 'Mutating a variable in a subexpression is not allowed',
          pos: subPos,
          subnotes: [],
          tags: #['subexpression-mutation'],
        }];
      }
    }

    if (type in operatorTypes.mutation) {
      mutation := Mutation(data[0], pos);

      notes ++= mutation.notes;

      nameTargets := mutation.nameTargets;
    }
  }

  return [expression, notes];
};

func Mutation(target, pos) {
  [type, data, _] := target;

  if (!(type in expressionTypes.mutable)) {
    return {
      notes: [{
        level: 'error',
        message: type ++ ' expression is not a valid mutation target',
        pos,
        subnotes: [],
        tags: #['mutation-target'],
      }],
      nameTargets: [],
      valid: false,
    };
  }

  if (type == 'identifier') {
    return {notes: [], nameTargets: [data]};
  }

  notes := [];
  nameTargets := [];
  valid := true;

  if (type in #['.', 'subscript']) {
    subTarget := data[0];
    subType := subTarget[0];

    if (!(subType in #['identifier', '.', 'subscript'])) {
      notes ++= [{
        level: 'error',
        message: (
          'In a mutation target, the left side of ' ++
          aan(type) ++
          ' expression cannot be ' ++
          aan(subType) ++
          ' expression'
        ),
        pos: subTarget[2],
        subnotes: [],
        tags: #['mutation-target'],
      }];

      valid = false;
    } else {
      subMutation := Mutation(subTarget);
      notes ++= subMutation.notes;
      nameTargets ++= subMutation.nameTargets;
      valid &&= subMutation.valid;
    }

    return {notes, nameTargets, valid};
  }

  subMutations := switch (type) {
    'array' => data:map(Mutation);
    'object' => data:map(func([_, subTarget]) => Mutation(subTarget));
  };

  for (subMutation of subMutations) {
    notes ++= subMutation.notes;
    nameTargets ++= subMutation.nameTargets;
    valid &&= subMutation.valid;
  }

  return {notes, nameTargets, valid};
};

return Expression;
