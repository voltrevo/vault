import ./Scope.vx;

return {
  create: func() => { parent: null, variables: {} },

  add: func(scope, name, data) {
    scope.variables[name] := data;
    return scope;
  },

  lookup: func(scope, name) {
    if (name in scope.variables:Keys()) {
      return scope.variables[name];
    }

    if (scope.parent:Kind() != 'null') {
      return Scope.lookup(scope.parent, name);
    }

    return null;
  },

  lookupDefault: func(scope, name, default_) {
    if (name in scope.variables:Keys()) {
      return scope.variables[name];
    }

    if (scope.parent:Kind() != 'null') {
      return Scope.lookupDefault(scope.parent, name, default_);
    }

    return default_;
  },

  update: func({parent, variables}, name, data) {
    if (name in variables:Keys()) {
      variables[name] = data;
    } else {
      parent = Scope.update(parent, name, data);
    }

    return {parent, variables};
  },

  push: func(scope) => { parent: scope, variables: {} },
  pop: func(scope) => scope.parent,

  combine: func(leftScope, rightScope, combiner) {
    if (leftScope in #[null]) {
      assert rightScope in #[null];
      return null;
    }

    variables := leftScope.variables;
    varNames := variables:Keys();
    assert rightScope.variables:Keys() == varNames;

    for (name of varNames:Values()) {
      variables[name] = combiner(
        leftScope.variables[name],
        rightScope.variables[name],
      );
    }

    return {
      parent: Scope.combine(leftScope.parent, rightScope.parent, combiner),
      variables,
    };
  },
};
