import @/util/SetFromArray.vx;

import Imports from './Imports/Program.vx';

import ./isolatedCompile.vx;

func compile(state, replies) {
  if (state:Kind() == 'null') {
    [[_, args]] := replies;

    if (args:Length() != 1u64) {
      log.info 'Expected 1 argument';
    }

    [entry] := args;

    state = {
      package: {
        files: {},
        entry,
      },
      fileRequests: [entry],
      allFileRequests: #[entry],
      notes: [],
    };

    return [state, [['read', entry]]];
  }

  nextFileRequests := [];
  newNotes := [];

  for ([file, lines] of [state.fileRequests, replies]:Transpose()) {
    log.info 'Isolated compile: @/' ++ file;
    {notes, tree} := isolatedCompile(lines);
    newNotes ++= notes:map(AddFileInfo:bind(file));

    imports := SetFromArray(Imports(tree):map(resolve:bind(Dir(file))));
    newImports := imports ~ state.allFileRequests;
    nextFileRequests ++= newImports:Values();
    state.allFileRequests |= newImports;

    state.package.files[file] := tree;
  }

  if (HasError(newNotes)) {
    return [null, [['output', state.notes]]];
  }

  state.fileRequests = nextFileRequests;
  state.notes ++= newNotes;

  if (state.fileRequests:Length() == 0u64) {
    return [
      null,
      [
        ['output', [
          'Compiled (isolated) ' ++
          state.package.files:Keys():Values():Length():String() ++
          ' files successfully'
        ]],
      ],
    ];
  }

  return [state, state.fileRequests:map(func(f) => ['read', f])];
};

func HasError(notes) {
  for (note of notes) {
    if (note.level == 'error') {
      return true;
    }
  }

  return false;
};

func AddFileInfo(file, note) {
  note.pos = [file, note.pos];
  return note;
};

func Dir(file) {
  res := '';
  stage := '';

  for (i := 0u64; i < file:Length(); i++) {
    stage ++= file[i];

    if (file[i] == '/') {
      res ++= stage;
      stage = '';
    }
  }

  return res;
};

func resolve(dir, importSrc) => switch(strTake(2u64, importSrc)) {
  '@/' => strDrop(2u64, importSrc);
  './' => dir ++ strDrop(2u64, importSrc);
};

func strTake(n, str) {
  res := '';

  for (i := 0u64; i < n && i < str:Length(); i++) {
    res ++= str[i];
  }

  return res;
};

func strDrop(n, str) {
  res := '';

  for (n < str:Length()) {
    res ++= str[n];
    n++;
  }

  return res;
};

return compile;
