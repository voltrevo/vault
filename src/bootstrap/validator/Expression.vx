import @/util/aan.vx;

import ./expressionTypes.vx;
import ./operatorTypes.vx;
import ./SubExpression.vx;

func Expression(expression) {
  notes := [];

  [type, data, pos] := expression;

  subExps := [];

  if (type in expressionTypes.operator) {
    if (type in operatorTypes.mutation) {
      [left, right] := data;

      notes ++= Mutation(left, pos);

      subExps ++= [right];
    } else if (type == 'functionCall') {
      [base, args] := data;
      subExps ++= [base] ++ args;
    } else {
      subExps ++= data;
    }
  } else if (type in expressionTypes.container) {
    subExps ++= switch (type) {
      'array' => data;
      'set' => data;
      'object' => data:map(func([_, exp]) => exp);
    };
  } else if (type in expressionTypes.nameAccess) {
    [left, _] := data;
    subExps ++= [left];
  } else if (type == 'note') {
    notes ++= [data];
  } else if (type == 'switch') {
    [test, cases] := data;
    subExps ++= [test] ++ cases:reduce(++);
  } else if (type in #['import', 'default', 'literal', 'identifier']) {
    // Nothing to do for these types
  } else if (type == 'func') {
    log.warn 'Unimplemented: validating func expression';
  } else {
    assert false;
  }

  notes ++= (
    [[]] ++ subExps:map(func(se) => SubExpression(se) ++ Expression(se))
  ):reduce(++);

  return notes;
};

func Mutation(target, pos) {
  func recurse(sub) => Mutation(sub, pos);

  [type, data, _] := target;

  if (!(type in expressionTypes.mutable)) {
    return [{
      level: 'error',
      message: type ++ ' expression is not a valid mutation target',
      pos,
      subnotes: [],
      tags: #['mutation-target'],
    }];
  }

  if (type == 'identifier') {
    return [];
  }

  notes := [];

  if (type in #['.', 'subscript']) {
    subTarget := data[0];
    subType := subTarget[0];

    if (!(subType in #['identifier', '.', 'subscript'])) {
      notes ++= [{
        level: 'error',
        message: (
          'In a mutation target, the left side of ' ++
          aan(type) ++
          ' expression cannot be ' ++
          aan(subType) ++
          ' expression'
        ),
        pos: subTarget[2],
        subnotes: [],
        tags: #['mutation-target'],
      }];
    } else {
      notes ++= recurse(subTarget);
    }

    return notes;
  }

  subMutations := switch (type) {
    'array' => data:map(recurse);
    'object' => data:map(func([_, subTarget]) => recurse(subTarget));
  };

  notes = ([notes] ++ subMutations):reduce(++);

  return notes;
};

return Expression;
