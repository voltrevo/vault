import ./transform2d.vx;
import ./canvasTree.vx;

return {
  flatten: func(object) {
    func impl(transform, [type, data]) => switch (type) {
      'polygon' => [['polygon', {
        points: data.points:map(transform2d.apply:bind(transform)),
        style: data.style,
      }]];

      'text' => [['text', (func() {
        newData := data;

        newData.transform = transform2d.compose(
          transform,
          data.transform
        );

        return newData;
      })()]];

      'group' => data:map(impl:bind(transform)):reduce(++);

      'transform' => impl(
        transform2d.compose(transform, data.transform),
        data.object,
      );
    };

    return impl(transform2d.identity, object);
  },

  App: func({init, reduce, render}) {
    func renderFlat(state) {
      {events, tree} := render(state);
      objects := canvasTree.flatten(tree);

      return {events, objects};
    };

    state := init;
    renders := [];

    for (i := 0; i < 10; i++) {
      renderData := renderFlat(state);
      renders ++= [render(state)];

      if (renderData.events:Length() == 0) {
        break;
      }

      event := renderData.events[i % renderData.events:Length()];

      state = reduce(state, [event, switch (event) {
        'frame' => {dt: 20};
        'click' => [i * 0.618 % 1, i * (0.618 ** 2) % 1];
      }]);
    }

    assert renders:Length() > 0;

    return {
      type: 'application.canvas',
      init,
      reduce,
      render: renderFlat,
    };
  },

  Group: func(objects) => ['group', objects],
  Transform: func(transform, object) => ['transform', {transform, object}],
  Poly: func({points, style}) => ['polygon', {points, style}],

  Text: func(content, options) {
    assert options.width > 0;
    assert options.height > 0;

    options.content := content;
    options.transform := transform2d.identity;

    return ['text', options];
  },
};
