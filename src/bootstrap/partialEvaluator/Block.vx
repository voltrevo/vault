import ./FunctionAndType.vx;
import ./Scope.vx;
import ./Statement.vx;

func IsHoist(statement) {
  // TODO: Short-circuit && would simplify this a lot
  if (statement[0] == 'expression') {
    if (statement[1][0] == 'func') {
      return true;
    }
  }

  return false;
};

return func(scope, [type, statements, pos]) {
  assert type == 'block'; // TODO: Destructure exact matches using literals

  scope = Scope.push(scope);
  newStatements := [];

  for ([i, statement] of statements:Entries()) { // TODO: Fix unused warning
    if (IsHoist(statement)) {
      {name, args: _, body: _} := statement[1][1];
      assert name[0] == 'identifier';
      [expression, fnType] := [null, null];
      {expression, type: fnType, scope} = FunctionAndType(scope, statement[1]);
      statements[i][1] = expression;
      scope = Scope.add(scope, name[1], fnType);
    }
  }

  reachable := true;

  for (statement of statements) {
    isHoist := IsHoist(statement);

    if (!isHoist) {
      {scope, statement} = Statement(scope, statement);
    }

    if (reachable) {
      if (!(statement in #[null])) {
        newStatements ++= [statement];

        if (statement[0] in #['break', 'continue', 'return']) {
          reachable = false;
        }
      }
    } else if (isHoist) {
      newStatements ++= [statement];
    }
  }

  scope = Scope.pop(scope);

  return {scope, block: [type, newStatements, pos]};
};
