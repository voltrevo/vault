import @/util/aan.vx;

import ./expressionTypes.vx;
import ./operatorTypes.vx;
import ./Program.vx;
import ./SubExpression.vx;

func Expression(expression) {
  notes := [];

  [type, data, _] := expression;

  subExps := [];

  if (type in expressionTypes.operator) {
    if (type in operatorTypes.mutation) {
      [left, right] := data;

      notes ++= Mutation(left);

      subExps ++= [right];
    } else if (type == 'functionCall') {
      [base, args] := data;
      subExps ++= [base] ++ args;
    } else {
      subExps ++= data;
    }
  } else if (type in expressionTypes.container) {
    subExps ++= switch (type) {
      'array' => data;
      'set' => data;
      'object' => data:map(func([_, exp]) => exp);
    };
  } else if (type in expressionTypes.nameAccess) {
    [left, _] := data;
    subExps ++= [left];
  } else if (type == 'note') {
    notes ++= [data];
  } else if (type == 'switch') {
    [test, cases] := data;
    subExps ++= [test] ++ cases:reduce(++);
  } else if (type in #['import', 'default', 'literal', 'identifier']) {
    // Nothing to do for these types
  } else if (type == 'func') {
    {name: _, args, body} := data;

    for (arg of args) {
      notes ++= Argument(arg);
    }

    [bodyType, bodyData] := body;

    notes ++= switch (bodyType) {
      'expression' => Expression(bodyData);
      'block' => Program(body);
    };
  } else {
    assert false;
  }

  notes ++= (
    [[]] ++ subExps:map(func(se) => SubExpression(se) ++ Expression(se))
  ):reduce(++);

  return notes;
};

func Mutation(target) {
  [type, data, pos] := target;

  if (!(type in expressionTypes.mutable)) {
    return [{
      level: 'error',
      message: type ++ ' expression is not a valid mutation target',
      pos,
      subnotes: [],
      tags: #['mutation-target'],
    }];
  }

  if (type == 'identifier') {
    return [];
  }

  notes := [];

  if (type in #['.', 'subscript']) {
    subTarget := data[0];
    subType := subTarget[0];

    if (!(subType in #['identifier', '.', 'subscript'])) {
      notes ++= [{
        level: 'error',
        message: (
          'In a mutation target, the left side of ' ++
          aan(type) ++
          ' expression cannot be ' ++
          aan(subType) ++
          ' expression'
        ),
        pos: subTarget[2],
        subnotes: [],
        tags: #['mutation-target'],
      }];
    } else {
      notes ++= Mutation(subTarget);
    }

    return notes;
  }

  subMutations := switch (type) {
    'array' => data:map(Mutation);
    'object' => data:map(func([_, subTarget]) => Mutation(subTarget));
  };

  notes = ([notes] ++ subMutations):reduce(++);

  return notes;
};

func Argument(target) {
  [type, data, pos] := target;

  if (type == 'identifier') {
    return [];
  }

  if (type in #['array', 'object']) {
    subArgs := switch (type) {
      'array' => data:map(Argument);
      'object' => data:map(func([_, subTarget]) => Argument(subTarget));
    };

    return ([[]] ++ subArgs):reduce(++);
  }

  return [{
    level: 'error',
    message: type ++ ' expression is not a valid argument',
    pos,
    subnotes: [],
    tags: #['argument'],
  }];
};

return Expression;
