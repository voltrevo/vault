import p from '@/util/parse.vx';

import @/parser/AppendPos.vx;
import @/parser/CommaSequence.vx;
import @/parser/Identifier.vx;
import @/parser/Invalid.vx;
import @/parser/Primitive/String.vx;
import @/parser/W.vx;

import ./DeferExpression.vx;

Colon := p.Exact(':');

Key := AppendPos(p.Select([Identifier, String]));

KeyValuePair := p.Select([
  p.Sequence([Key, [W.Optional], [Colon], [W.Optional], DeferExpression]),
  p.Transform(AppendPos(Identifier), func(key) => [key, key]),
]);

RawObject := p.SequenceOne([
  [p.Exact('{')],
  CommaSequence(KeyValuePair),
  [p.Exact('}')],
]);

Object := p.Transform(
  RawObject,
  func(pairs) {
    if (pairs:Length() == 0u64) {
      return ['object', []];
    }

    invalid := Invalid(pairs:reduce(++));

    if (invalid:Kind() != 'null') {
      return invalid;
    }

    res := [];

    for ([[_, key, pos], value] of pairs) {
      if (key in res:Keys()) {
        return [
          'invalid',
          ['object has duplicate key \'' ++ key ++ '\' at ' ++ pos:String()],
        ];
      }

      res ++= [[key, value]];
    }

    return ['object', res];
  },
);

return Object;
