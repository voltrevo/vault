import p from '@/parse/parse.vx';

import ./Identifier.vx;
import ./Literal/Array.vx;
import ./Literal/Literal.vx;
import ./Literal/Object.vx;
import ./Literal/Set.vx;
import ./Literal/String.vx;
import ./Program.vx;

func arr(s) => p.Complete(Array)([s])[1];

assert arr('[]') == [];
assert arr('[1, 2, 3]') == [1, 2, 3];
assert arr('[1, [2], 3]') == [1, [2], 3];
assert arr('[1, [2], 3,]') == [1, [2], 3];

func set_(s) => p.Complete(Set)([s])[1];

assert set_('#[]') == #[];
assert set_('#[2, 3, 3, 1]') == #[1, 2, 3];

func str(s) => p.Complete(String)([s])[1];

assert str('\'foo\'') == 'foo';
assert str('\'fo\\\'o\'') == 'fo\'o';

func ident(s) => p.Complete(Identifier)([s]);

assert ident('x') == ['identifier', 'x'];
assert ident('foo123') == ['identifier', 'foo123'];

func obj(s) => p.Complete(Object)([s]);

assert obj('{}')[1] == {};
assert obj('{a: 1, b: 2}')[1] == {a: 1, b: 2};
assert obj('{\'a\': 1, a: 2}')[0] == 'invalid';

func lit(s) => p.Complete(Literal)([s])[1];

assert lit('{}') == {};

assert lit('[null, false, 200u8, \'foo\', [], #[], {}]') == [
  null,
  false,
  200u8,
  'foo',
  [],
  #[],
  {},
];

assert Program(['13i8']) == [
  {data: ['literal', 13i8], pos: [[0u64, 0u64], [0u64, 4u64]]},
  {data: ['whitespace'], pos: [[0u64, 4u64], [1u64, 0u64]]},
];

if (0u8:String() == '0u8') {
  sampleLines := [
    '123u64 ',
    '',
    '500u8',
    ' ',
    '  321u64 ',
    '[]',
  ];

  program := Program(sampleLines);

  assert program == [
    {data: ['literal', 123u64], pos: [[0u64, 0u64], [0u64, 6u64]]},
    {data: ['whitespace'], pos: [[0u64, 6u64], [2u64, 0u64]]},
    {data: ['overflow'], pos: [[2u64, 0u64], [2u64, 5u64]]},
    {data: ['whitespace'], pos: [[2u64, 5u64], [4u64, 2u64]]},
    {data: ['literal', 321u64], pos: [[4u64, 2u64], [4u64, 8u64]]},
    {data: ['whitespace'], pos: [[4u64, 8u64], [5u64, 0u64]]},
    {data: ['literal', []], pos: [[5u64, 0u64], [5u64, 2u64]]},
    {data: ['whitespace'], pos: [[5u64, 2u64], [6u64, 0u64]]},
  ];
}

return 'done';
