import ./Block.vx;
import ./Expression.vx;
import ./KindSet.vx;
import ./KindsString.vx;

func Statement([type, data, pos]) {
  if (type in #['return', 'assert', 'log.info', 'log.warn', 'log.error']) {
    return [type, Expression(data), pos];
  }

  if (type == 'if') {
    {condition, body, tail} := data;

    condition = Expression(condition);

    conditionKinds := KindSet(condition);

    if (!('bool' in conditionKinds)) {
      return ['note', {
        level: 'error',
        message: (
          'Condition needs to be a bool but instead is a ' ++
          KindsString(conditionKinds)
        ),
        pos: condition[2],
        subnotes: [],
        tags: #['type-error', 'non-bool-condition'],
      }];
    }

    if (condition[0] == 'literal' && condition[1]:Kind() == 'bool') {
      if (condition[1]) {
        // TODO: Still analyze tail? Warn about unreachable code?
        tail = ['nothing', null, tail[2]];
      } else {
        return switch (tail[0]) {
          'block' => ['if', {
            condition: ['literal', true, condition[2]],
            body: Block(tail),
            tail: ['nothing', null, condition[2]],
          }, tail[2]];

          'nothing' => tail;
          'if' => Statement(tail);
        };
      }
    }

    body = Block(body);

    tail = switch (tail[0]) {
      'nothing' => tail;
      'block' => Block(tail);
      'if' => Statement(tail);
    };

    return [type, {condition, body, tail}, pos];
  }

  if (type == 'for') {
    {control: [controlType, controlData, controlPos], body} := data;

    if (controlType == 'condition') {
      controlData = Expression(controlData);
    } else if (controlType == 'traditional') {
      {setup, condition, next} := controlData;
      setup = Expression(setup);
      condition = Expression(condition);
      next = Expression(next);
      controlData = {setup, condition, next};
    } else if (controlType == 'range') {
      {element, container} := controlData;
      container = Expression(container);
      controlData = {element, container};
    } else if (controlType == 'nothing') {
      // Nothing to do
    } else {
      assert false;
    }

    body = Block(body);

    return [
      type,
      {control: [controlType, controlData, controlPos], body},
      pos
    ];
  }

  if (type == 'expression') {
    return [type, Expression(data), pos];
  }

  assert type in #['break', 'continue', 'note', 'import', 'breakpoint'];
  return [type, data, pos];
};

return Statement;
