import @/util/aan.vx;

import ./expressionTypes.vx;
import ./operatorTypes.vx;
import ./SubExpression.vx;

func Expression(expression) {
  notes := [];
  naming := [];

  [type, data, pos] := expression;

  subExps := [];

  if (type == 'identifier') {
    naming ++= [NameOp('use', expression)];
  } else if (type in expressionTypes.operator) {
    if (type in operatorTypes.mutation) {
      [left, right] := data;

      style := switch (type) {
        ':=' => 'create';
        default => 'mutate';
      };

      mutation := Mutation(left, style, pos);
      notes ++= mutation.notes;
      naming ++= mutation.naming;

      subExps ++= [right];
    } else {
      subExps ++= data;
    }
  } else if (type in expressionTypes.container) {
    subExps ++= switch (type) {
      'array' => data;
      'set' => data;
      'object' => data:map(func([_, exp]) => exp);
    };
  } else if (type in expressionTypes.nameAccess) {
    [left, _] := data;
    subExps ++= [left];
  } else if (type == 'note') {
    notes ++= [data];
  } else if (type == 'switch') {
    [test, cases] := data;
    subExps ++= [test] ++ cases:reduce(++);
  } else if (type in #['import', 'default']) {
    // Nothing to do for these types
  } else if (type == 'func') {
    log.warn 'Unimplemented: validating func expression';
  } else {
    assert false;
  }

  notes ++= subExps:map(SubExpression):reduce(++);

  for ({notes: subNotes, naming: subNaming} of subExps:map(Expression)) {
    notes ++= subNotes;
    naming ++= subNaming;
  }

  return {notes, naming};
};

func Mutation(target, style, pos) {
  func recurse(sub) => Mutation(sub, style, pos);

  [type, data, _] := target;

  if (!(type in expressionTypes.mutable)) {
    return {
      notes: [{
        level: 'error',
        message: type ++ ' expression is not a valid mutation target',
        pos,
        subnotes: [],
        tags: #['mutation-target'],
      }],
      naming: [],
    };
  }

  if (type == 'identifier') {
    return {notes: [], naming: [NameOp(style, target)]};
  }

  notes := [];
  naming := [];

  if (type in #['.', 'subscript']) {
    subTarget := data[0];
    subType := subTarget[0];

    if (!(subType in #['identifier', '.', 'subscript'])) {
      notes ++= [{
        level: 'error',
        message: (
          'In a mutation target, the left side of ' ++
          aan(type) ++
          ' expression cannot be ' ++
          aan(subType) ++
          ' expression'
        ),
        pos: subTarget[2],
        subnotes: [],
        tags: #['mutation-target'],
      }];
    } else {
      subMutation := recurse(subTarget);
      notes ++= subMutation.notes;
      naming ++= subMutation.naming;
    }

    return {notes, naming};
  }

  subMutations := switch (type) {
    'array' => data:map(recurse);
    'object' => data:map(func([_, subTarget]) => recurse(subTarget));
  };

  for (subMutation of subMutations) {
    notes ++= subMutation.notes;
    naming ++= subMutation.naming;
  }

  return {notes, naming};
};

func NameOp(style, [_, name, pos]) => [style, name, pos];

return Expression;
