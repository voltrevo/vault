import @/files.vx;

import ./ByteCoder.vx;

return {
  indent: func(line) => '  ' ++ line,

  create: func(file) {
    return {
      file,
      dir: files.Dir(file),
      names: {},
      internalNames: {},
    };
  },

  setGFunc: func(coder, name, captures) {
    coder.names[name] := {t: 'gfunc', captures};
    return coder;
  },

  setMFunc: func(coder, name, fullName) {
    coder.names[name] := {t: 'mfunc', fullName};
    return coder;
  },

  getName: func(coder, name) {
    if (!(name in coder.names:Keys())) {
      return ['get $' ++ name];
    }

    entry := coder.names[name];

    return switch (entry.t) {
      'gfunc' => (func() {
        if (entry.captures.length == 0) {
          return ['func { gcall $' ++ name ++ ' }'];
        }

        lines := ['func { gcall $.captureless.' ++ name ++ ' }'];

        for (capture of entry.captures) {
          getNameLines := ByteCoder.getName(coder, capture);

          lines ++= switch (getNameLines:Length()) {
            1u64 => [getNameLines[0] ++ ' bind'];
            default => getNameLines ++ ['bind'];
          };
        }

        return lines;
      })();

      'mfunc' => ['mcall $' ++ entry.fullName];
    };
  },

  getInternalName: func(coder, name) {
    if (!(name in coder.internalNames:Keys())) {
      coder.internalNames[name] := 0;
    }

    resName := '.' ++ name ++ coder.internalNames[name]:String();
    coder.internalNames[name]++;

    return [resName, coder];
  },
};
