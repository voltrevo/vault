import ./applyScopeEvents.vx;
import ./Statement.vx;

func CaptureMutationNote({name, pos, capture, mutate}) {
  tags := #['scope', 'capture-mutation'];

  subnotes := [{
    level: 'info',
    message: (
      '{' ++
      name ++
      '} is captured at ' ++
      capture[0][2]:String() ++
      ' and mutated at ' ++
      mutate[0][2]:String()
    ),
    pos,
    subnotes: [],
    tags,
  }];

  for (i := 1u64; i < mutate:Length(); i++) {
    [_, _, mPos] := mutate[i];

    subnotes ++= [{
      level: 'error',
      message: 'Can\'t mutate captured variable {' ++ name ++ '}',
      pos: mPos,
      subnotes: [],
      tags,
    }];
  }

  subnotes ++= capture:map(func([_, _, cPos]) => {
    level: 'info',
    message: (
      'Capturing {' ++
      name ++
      '} here prevents mutation at ' ++
      mutate[0][2]:String()
    ),
    pos: cPos,
    subnotes: [],
    tags,
  });

  return {
    level: 'error',
    message: 'Can\'t mutate captured variable {' ++ name ++ '}',
    pos: mutate[0][2],
    subnotes,
    tags,
  };
};

func IncompleteClosureNote({hoist, capture}) {
  tags := #['scope', 'incomplete-closure'];

  return {
    level: 'error',
    message: (
      'Function {' ++
      hoist.name ++
      '} is not available here because it captures {' ++
      capture.name ++
      '} which doesn\'t exist until after ' ++
      capture.creationPos:String()
    ),
    pos: hoist.usePos,
    subnotes: [
      {
        level: 'info',
        message: (
          'Captured variable {' ++
          capture.name ++
          '} doesn\'t exist when {' ++
          hoist.name ++
          '} is accessed at ' ++
          hoist.usePos:String()
        ),
        pos: capture.pos,
        subnotes: [],
        tags,
      },
      {
        level: 'info',
        message: (
          'There is an attempt to indirectly access variable {' ++
          capture.name ++
          '} when it doesn\'t exist at ' ++
          hoist.usePos:String()
        ),
        pos: capture.creationPos,
        subnotes: [],
        tags,
      },
    ],
  };
};

return func(preEvents, [type, statements, _]) {
  assert type == 'block'; // TODO: Destructure exact matches using literals

  hoistCaptures := {};
  sLen := statements:Length();

  for (i := 0u64; i < sLen; i++) {
    sEvents := null;

    if (statements[i][0] == 'expression') {
      if (statements[i][1][0] == 'func') {
        name := statements[i][1][1].name;

        if (name[0] != 'nothing' && !(name[1] in hoistCaptures:Keys())) {
          preEvents = [['create', name, []]] ++ preEvents;
          statements[i][1][1].name = ['nothing', null, statements[i][1][1].name[2]];
          captures := [];
          sEvents = Statement(statements[i]);

          // TODO: array:filter
          for (evt of sEvents) {
            if (evt[0] == 'capture') {
              captures ++= [evt];
            }
          }

          hoistCaptures[name[1]] := captures;
        }
      }
    }

    if (sEvents in #[null]) {
      sEvents = Statement(statements[i]);
    }

    preEvents ++= sEvents;
  }

  {scope, events} := applyScopeEvents({}, preEvents);

  for ([name, {pos, use, capture, mutate}] of scope:Entries()) {
    if (use:Length() + capture:Length() == 0u64) {
      events ++= [['note', {
        level: 'warn',
        message: 'Variable {' ++ name ++ '} is not used',
        pos,
        subnotes: [],
        tags: #['scope', 'no-effect', 'unused'],
      }]];
    }

    if (capture:Length() > 0u64 && mutate:Length() > 0u64) {
      events ++= [['note', CaptureMutationNote({
        name,
        pos,
        capture,
        mutate
      })]];
    }
  }

  for ([hoistName, captures] of hoistCaptures:Entries()) {
    for ([_, _, usePos] of scope[hoistName].use) {
      for ([_, [_, captureName, capturePos]] of captures) {
        captureCreationPos := scope[captureName].pos;

        if (usePos < captureCreationPos) {
          events ++= [['note', IncompleteClosureNote({
            hoist: {
              name: hoistName,
              usePos,
            },
            capture: {
              name: captureName,
              pos: capturePos,
              creationPos: captureCreationPos,
            }
          })]];
        }
      }
    }
  }

  return events;
};
