import @/util/aan.vx;

import ./expressionTypes.vx;
import ./operatorTypes.vx;
import ./SubExpression.vx;

func Expression(expression) {
  notes := [];
  naming := [];

  [type, data, pos] := expression;

  if (type == 'identifier') {
    naming ++= [NameOp('use', expression)];
  } else if (type in expressionTypes.operator) {
    for (subExp of data) {
      notes ++= SubExpression(subExp);
    }

    if (type in operatorTypes.mutation) {
      [left, right] := data;

      style := switch (type) {
        ':=' => 'create';
        default => 'mutate';
      };

      mutation := Mutation(left, style, pos);
      notes ++= mutation.notes;
      naming ++= mutation.naming;

      valRight := Expression(right);

      notes ++= valRight.notes;
      naming ++= valRight.naming;
    } else {
      for ({notes: subNotes, naming: subNaming} of data:map(Expression)) {
        notes ++= subNotes;
        naming ++= subNaming;
      }
    }
  } else if (type in expressionTypes.container) {
    subs := switch (type) {
      'array' => data;
      'set' => data;
      'object' => data:map(func([_, exp]) => exp);
    };

    for ({notes: subNotes, naming: subNaming} of subs:map(Expression)) {
      notes ++= subNotes;
      naming ++= subNaming;
    }
  }

  return {notes, naming};
};

func Mutation(target, style, pos) {
  func recurse(sub) => Mutation(sub, style, pos);

  [type, data, _] := target;

  if (!(type in expressionTypes.mutable)) {
    return {
      notes: [{
        level: 'error',
        message: type ++ ' expression is not a valid mutation target',
        pos,
        subnotes: [],
        tags: #['mutation-target'],
      }],
      naming: [],
    };
  }

  if (type == 'identifier') {
    return {notes: [], naming: [NameOp(style, target)]};
  }

  notes := [];
  naming := [];

  if (type in #['.', 'subscript']) {
    subTarget := data[0];
    subType := subTarget[0];

    if (!(subType in #['identifier', '.', 'subscript'])) {
      notes ++= [{
        level: 'error',
        message: (
          'In a mutation target, the left side of ' ++
          aan(type) ++
          ' expression cannot be ' ++
          aan(subType) ++
          ' expression'
        ),
        pos: subTarget[2],
        subnotes: [],
        tags: #['mutation-target'],
      }];
    } else {
      subMutation := recurse(subTarget);
      notes ++= subMutation.notes;
      naming ++= subMutation.naming;
    }

    return {notes, naming};
  }

  subMutations := switch (type) {
    'array' => data:map(recurse);
    'object' => data:map(func([_, subTarget]) => recurse(subTarget));
  };

  for (subMutation of subMutations) {
    notes ++= subMutation.notes;
    naming ++= subMutation.naming;
  }

  return {notes, naming};
};

func NameOp(style, [_, name, pos]) => [style, name, pos];

return Expression;
