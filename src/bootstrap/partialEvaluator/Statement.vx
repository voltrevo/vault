import ./Block.vx;
import ./Expression.vx;
import ./KindSet.vx;
import ./KindsString.vx;
import ./Scope.vx;
import ./Type.vx;

func Statement(scope, [type, data, pos]) {
  if (type in #['return', 'assert', 'log.info', 'log.warn', 'log.error']) {
    expression := null;
    {scope, expression} = Expression(scope, data);
    return {scope, statement: [type, expression, pos]};
  }

  if (type == 'if') {
    {condition, body, tail} := data;

    {scope, expression: condition} = Expression(scope, condition);

    conditionKinds := KindSet(condition);

    if (!('bool' in conditionKinds)) {
      return {
        scope,
        statement: NonBoolConditionNote(condition, conditionKinds),
      };
    }

    if (condition[0] == 'literal' && condition[1]:Kind() == 'bool') {
      if (condition[1]) {
        // TODO: Still analyze tail? Warn about unreachable code?
        tail = ['nothing', null, tail[2]];
      } else {
        {scope, statement: tail} = switch (tail[0]) {
          'block' => ScopeBlock(tail[1]);
          'nothing' => {scope, statement: tail};
          'if' => Statement(tail);
        };
      }
    }

    bodyScope := null;
    tailScope := null;
    {scope: bodyScope, block: body} = Block(scope, body);

    {scope: tailScope, tail} = switch (tail[0]) {
      'nothing' => {tail, scope};
      'block' => Block(scope, tail);
      'if' => Statement(scope, tail);
    };

    return {
      scope: Scope.combine(bodyScope, tailScope, Type.Union),
      statement: [type, {condition, body, tail}, pos],
    };
  }

  if (type == 'for') {
    {control: [controlType, controlData, controlPos], body} := data;

    if (controlType == 'condition') {
      {scope, expression: controlData} = Expression(scope, controlData);
      condition := controlData;

      conditionKinds := KindSet(condition);

      if (!('bool' in conditionKinds)) {
        return {
          scope,
          statement: NonBoolConditionNote(condition, conditionKinds),
        };
      }

      if (condition[0] == 'literal' && condition[1]:Kind() == 'bool') {
        if (condition[1]) {
          controlType = 'nothing';
          controlData = null;
        } else {
          return {scope, statement: ['expression', controlData, pos]};
        }
      }
    } else if (controlType == 'traditional') {
      /* TODO: update with scope
      {setup, condition, next} := controlData;

      condition = Expression(condition);
      conditionKinds := KindSet(condition);

      if (!('bool' in conditionKinds)) {
        return NonBoolConditionNote(condition, conditionKinds);
      }

      if (condition[0] == 'literal' && condition[1]:Kind() == 'bool') {
        if (!condition[1]) {
          // Only interested in the possibility of this being an exception
          return ScopeBlock([['expression', setup, setup[2]]]);
        }
      }

      setup = Expression(setup);
      next = Expression(next);
      controlData = {setup, condition, next};
      */
    } else if (controlType == 'range') {
      /* TODO: update with scope
      {element, container} := controlData;
      container = Expression(container);

      containerKinds := KindSet(container);

      if (!('array' in containerKinds)) {
        return ['note', {
          level: 'error',
          message: (
            'Container of for control clause needs to be an array but ' ++
            'instead is a ' ++
            KindsString(containerKinds)
          ),
          pos: container[2],
          subnotes: [],
          tags: #['type-error', 'non-array-container'],
        }];
      }

      if (container[0] == 'literal' && container[1]:Kind() == 'array') {
        if (container[1]:Length() == 0u64) {
          return ['nothing', null, pos];
        }

        // TODO: Loop unrolling for small arrays? Includes array expressions,
        // not just literals.
      }

      controlData = {element, container};
      */
    } else if (controlType == 'nothing') {
      // Nothing to do
    } else {
      assert false;
    }

    // TODO: Process scope possibilities from running unknown iterations
    // TODO: Not updating the scope will actually break things like this:
    // x := 3;
    // for (true) {
    //   x = 'foo';
    //   break;
    // }
    // return x ++ 'bar';
    body = Block(scope, body).block;

    return {
      scope,
      statement: [
        'for',
        {control: [controlType, controlData, controlPos], body},
        pos
      ],
    };
  }

  if (type == 'expression') {
    expression := null;
    {scope, expression} = Expression(scope, data);
    return {scope, statement: [type, expression, pos]};
  }

  if (type == 'import') {
    return {
      scope: Scope.add(scope, data.name[1], Type.Any),
      statement: [type, data, pos],
    };
  }

  assert type in #['break', 'continue', 'note', 'breakpoint'];
  return {scope, statement: [type, data, pos]};
};

func NonBoolConditionNote(condition, conditionKinds) {
  return ['note', {
    level: 'error',
    message: (
      'Condition needs to be a bool but instead is a ' ++
      KindsString(conditionKinds)
    ),
    pos: condition[2],
    subnotes: [],
    tags: #['type-error', 'non-bool-condition'],
  }];
};

func ScopeBlock(statements) {
  assert statements:Length() > 0u64;

  pos := [statements:Front()[2][0], statements:Back()[2][1]];

  return ['if', {
    condition: ['literal', true, pos],
    body: Block(['block', statements, pos]),
    tail: ['nothing', null, pos],
  }, pos];
};

return Statement;
