import @/scopeValidator/Argument.vx;

import ./Block.vx;
import ./DestructureType.vx;
import ./ExpressionAndType.vx;
import ./Scope.vx;
import ./Type.vx;

return func(scope, [xType, {name, args, body}, pos]) {
  assert xType == 'func';

  argsType := args:map(DestructureType);

  fnScope := Scope.push(scope);
  
  for (arg of args) {
    for ([evtType, identifier, _] of Argument(arg)) {
      if (evtType == 'create') {
        fnScope = Scope.add(fnScope, identifier[1], Type.Any);
      }
    }
  }

  if (body[0] == 'block') {
    // TODO: Need to get type information from block partial evaluation

    return {
      scope,
      expression: ['func', {name, args, body: Block(fnScope, body).block}, pos],
      type: ['func', {args: argsType, output: Type.Any}],
    };
  }

  if (body[0] == 'expression') {
    bodyPos := body[2];
    body = ExpressionAndType(fnScope, body[1]);

    type := switch (body.type[0]) {
      // TODO: This `never` would still be included in the output type, is it
      // necessary to escalate it?
      'never' => body.type;

      default => ['func', {args: argsType, output: body.type}];
    };

    return {
      scope,
      expression: [
        'func',
        {name, args, body: ['expression', body.expression, bodyPos]},
        pos
      ],
      type,
    };
  }

  return switch{};
};
