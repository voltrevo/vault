import ./Block.vx;
import ./Expression.vx;
import ./KindSet.vx;
import ./KindsString.vx;

func Statement([type, data, pos]) {
  if (type in #['return', 'assert', 'log.info', 'log.warn', 'log.error']) {
    return [type, Expression(data), pos];
  }

  if (type == 'if') {
    {condition, body, tail} := data;

    condition = Expression(condition);

    conditionKinds := KindSet(condition);

    if (!('bool' in conditionKinds)) {
      return NonBoolConditionNote(condition, conditionKinds);
    }

    if (condition[0] == 'literal' && condition[1]:Kind() == 'bool') {
      if (condition[1]) {
        // TODO: Still analyze tail? Warn about unreachable code?
        tail = ['nothing', null, tail[2]];
      } else {
        return switch (tail[0]) {
          'block' => ScopeBlock(tail[1]);
          'nothing' => tail;
          'if' => Statement(tail);
        };
      }
    }

    body = Block(body);

    tail = switch (tail[0]) {
      'nothing' => tail;
      'block' => Block(tail);
      'if' => Statement(tail);
    };

    return [type, {condition, body, tail}, pos];
  }

  if (type == 'for') {
    {control: [controlType, controlData, controlPos], body} := data;

    if (controlType == 'condition') {
      controlData = Expression(controlData);
      condition := controlData;

      conditionKinds := KindSet(condition);

      if (!('bool' in conditionKinds)) {
        return NonBoolConditionNote(condition, conditionKinds);
      }

      if (condition[0] == 'literal' && condition[1]:Kind() == 'bool') {
        if (condition[1]) {
          controlType = 'nothing';
          controlData = null;
        } else {
          return ['nothing', null, pos];
        }
      }
    } else if (controlType == 'traditional') {
      {setup, condition, next} := controlData;

      condition = Expression(condition);
      conditionKinds := KindSet(condition);

      if (!('bool' in conditionKinds)) {
        return NonBoolConditionNote(condition, conditionKinds);
      }

      if (condition[0] == 'literal' && condition[1]:Kind() == 'bool') {
        if (!condition[1]) {
          // Only interested in the possibility of this being an exception
          return ScopeBlock([['expression', setup, setup[2]]]);
        }
      }

      setup = Expression(setup);
      next = Expression(next);
      controlData = {setup, condition, next};
    } else if (controlType == 'range') {
      {element, container} := controlData;
      container = Expression(container);

      containerKinds := KindSet(container);

      if (!('array' in containerKinds)) {
        return ['note', {
          level: 'error',
          message: (
            'Container of for control clause needs to be an array but ' ++
            'instead is a ' ++
            KindsString(containerKinds)
          ),
          pos: container[2],
          subnotes: [],
          tags: #['type-error', 'non-array-container'],
        }];
      }

      if (container[0] == 'literal' && container[1]:Kind() == 'array') {
        if (container[1]:Length() == 0u64) {
          return ['nothing', null, pos];
        }

        // TODO: Loop unrolling for small arrays? Includes array expressions,
        // not just literals.
      }

      controlData = {element, container};
    } else if (controlType == 'nothing') {
      // Nothing to do
    } else {
      assert false;
    }

    body = Block(body);

    return [
      type,
      {control: [controlType, controlData, controlPos], body},
      pos
    ];
  }

  if (type == 'expression') {
    return [type, Expression(data), pos];
  }

  assert type in #['break', 'continue', 'note', 'import', 'breakpoint'];
  return [type, data, pos];
};

func NonBoolConditionNote(condition, conditionKinds) {
  return ['note', {
    level: 'error',
    message: (
      'Condition needs to be a bool but instead is a ' ++
      KindsString(conditionKinds)
    ),
    pos: condition[2],
    subnotes: [],
    tags: #['type-error', 'non-bool-condition'],
  }];
};

func ScopeBlock(statements) {
  assert statements:Length() > 0u64;

  pos := [statements:Front()[2][0], statements:Back()[2][1]];

  return ['if', {
    condition: ['literal', true, pos],
    body: Block(['block', statements, pos]),
    tail: ['nothing', null, pos],
  }, pos];
};

return Statement;
